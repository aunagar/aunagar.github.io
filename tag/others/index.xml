<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Others | Ajay Unagar</title>
    <link>https://aunagar.github.io/tag/others/</link>
      <atom:link href="https://aunagar.github.io/tag/others/index.xml" rel="self" type="application/rss+xml" />
    <description>Others</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Thu, 27 Feb 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://aunagar.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Others</title>
      <link>https://aunagar.github.io/tag/others/</link>
    </image>
    
    <item>
      <title>Making robots dance (in simulation)</title>
      <link>https://aunagar.github.io/project/robodance/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://aunagar.github.io/project/robodance/</guid>
      <description>&lt;div style=&#34;text-align: justify&#34;&gt;
&lt;p&gt;In this project, we used inverse kinematics (IK) to build simple walking gaits for the hexapod. Furthermore, these walking gaits were combined using a motion graph to create complicated motion trajectories for the robot. Furthermore, we used these gaits along with the target following objective to make robot autonomously move to the target position. We also design pre-specified gaits using motion graph, which allow robot to &lt;a href=&#34;https://youtu.be/c9aaSq0QW1I?t=246&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;dance&lt;/a&gt;!&lt;/p&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Parallel algorithms for Subgraph Isomorphism (OpenMP and MPI)</title>
      <link>https://aunagar.github.io/project/hpc/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://aunagar.github.io/project/hpc/</guid>
      <description>&lt;div style=&#34;text-align: justify&#34;&gt;
&lt;p&gt;We proposed two parallel implementations of popular subgraph isomorphism solvers: VF2 and Glasgow. The recursive DFS in VF2 was parallelized using OpenMP tasks, and we aimed to limit the excessive work done by additional threads. In Glasgow, we parallelized the complete algorithm using OpenMP, and we put special attention to compiler optimizations and OpenMP task amount limitation. Furthermore, a large section of Glasgow was parallelized with MPI one-sided communication. All the implementations are benchmarked on a wide range of graph pairs from literature, and we compare our Glasgow OpenMP implementation with the parallel version proposed by the author of Glasgow algorithm. We discuss when good scaling can be expected, and where improvements are possible.&lt;/p&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>
